<!---
pandoc table-of-contents.md -o table-of-contents.html --css pandoc.css -s --mathjax --metadata title="Table of Contents" && open table-of-contents.html
-->

- author: John A. Marohn
- created: 2024-10-29
- last updated: 2025-12-07


# Software

The `dissipationtheory/dissipationtheory` folder contains both current and obsolete code.  Here I summarize the most useful parts of the current code.

- `constants` contains a `pint`-package unit registry `ureg` and physical constants with units: Bolztmann's constant `kb`, free space permittivity `epsilon0`, the magnitude of the electron charge `qe`, and room temperature `Troom` (i.e. $T = 300$ K).

- `dissipation9a` contains data classes 
  - `CantileverModel`
  - `SampleModel1`
  - `SampleModel2`
  - `SampleModel3`

- `dissipation9b` contains data classes 
  - `SampleModel1Jit`
  - `SampleModel2Jit`
  - `SampleModel3Jit`

- `dissipation13e.py` contains the class `twodimCobject`:
  - Tip model: sphere or sphere-plus cone
  - Calculation method: `numba`, CPU
  - Samples modeled: Type I, II, III, and IV
  - Calculated: capacitance derivatives, force, friction, frequency shift (dc, ac, am)

- `dissipation16e.py` contains the class `twodimCobject`:
  - Tip model: sphere or sphere-plus cone
  - Calculation method: `torch`, GPU
  - Samples modeled: Type I and III
  - Calculated: capacitance derivatives, force, friction, frequency shift (dc, ac, am)

- `dissipation17e.py` contains the class `pointprobeCobject`:
  - Tip model: point probe
  - Calculation method: `numba`, CPU
  - Samples modeled: Type I, II, III, and IV
  - Calculated: friction and frequency shift (dc, ac)


# Studies

In the `dissipationtheory/development` folder there are a number of *studies* --- Jupyter notebooks in which I experimented with calculation and data-analysis code.  The studies have names like `dissipation-theory--Study-1.ipynb` and so forth.  Here I summarize these studies.  

- **Study 1** ([html](dissipation-theory--Study-1.html)).  Explore Loring's recently revised theory for friction over metals.

- **Study 2** ([html](dissipation-theory--Study-2.html)).  Explore Lekkala and Loring's theory for friction over a semiconductor backed by a metal.

- **Study 3** ([html](dissipation-theory--Study-3.html)).  Try to reproduce Figure 7(b) and Figure 9(b) from Lekkala2012.

- **Study 4** ([html](dissipation-theory--Study-4.html)). Look at ways to cut down code redundancy in the code in Study 3 ([html](dissipation-theory--Study-3.html)). It would greatly simplify my code if the sample object would update the diffusion length automatically when the mobility or cantilever period was updated.

- **Study 5** ([html](dissipation-theory--Study-5.html)). Look at ways to cut down code redundancy in the code in Study 4 ([html](dissipation-theory--Study-4.html)).

- **Study 6** ([html](dissipation-theory--Study-6.html)).  Reproduce the friction $\gamma_{\parallel}$ versus charge density $\rho$ plots in Lekkala2013 Figure 7(b) using the functions in `dissipationtheory.dissipation.py`. The computation is carried out over 40 charge densities, for 4 charge mobilities, and using Model I and Model II in the paper. The computation in done two ways -- in pure Python and in `numba`-compiled Python. The computation takes approximately 2.4 min in pure Python and 0.6 s in `numba`-compiled Python.

- **Study 7** ([html](dissipation-theory--Study-7.html)).  A computation of friction was carried out over 40 charge densities and 5 values of the imaginary dielectric constant $\epsilon_{\mathrm{s}}^{\prime \prime}$, using a `numba`-compiled Python version of Model II in the paper. The computation takes less than a second.

  In the paper, the tip-sample separation $d$ was not specified. A first computation was done with $d = 300 \: \mathrm{\mu m}$, but the agreement with Lekkala was poor. The tip-sample separation was varied between 30 nm and 300 nm in 1 nm increments and the sum-squared deviation $\chi^2$ between the computed dissipation and Lekkala's dissipation calculated for the $\epsilon_{\mathrm{s}}^{\prime \prime} = 0$ case. The $\chi^2$ was minimized at an optimal tip-sample separation of $d_{\mathrm{opt}} = 101.0 \: \mathrm{nm}$. Computations performed with $d = d_{\mathrm{opt}}$ were in very good agreement with Lekkala over a range of $\epsilon_{\mathrm{s}}^{\prime \prime}$ values.

  Instead of minimizing $\chi^2$ using the $\epsilon_{\mathrm{s}}^{\prime\prime} = 0$ dataset, minimize it over all five data sets. Moreover, minimize the relative error, not the absolute error. This gives all the curves equal weight, even though they have quite different peak $\gamma_{\perp}$ values. The $\chi^2$ is now minimized at an optimal tip-sample separation of $d_{\mathrm{opt}} = 100.0 \: \mathrm{nm}$. Computations are are essentially unchanged.
  
- **Study 8** ([html](dissipation-theory--Study-8.html)).  Examine the unitless 0th and 1st derivatives of the sphere capacitance.

- **Study 9** ([html](dissipation-theory--Study-9.html)).  Reproduce the friction $\gamma_{\perp}$ versus charge density $\rho$ plots in Lekkala2013 Figure 9(b) using functions in `dissipationtheory.dissipation.py`. Add in a low-density approximation.

- **Study 10** ([html](dissipation-theory--Study-10.html)).  Plot the friction $\gamma_{\perp}$ versus height $h$ expected for a thin organic semiconductor sample backed by a metal.

- **Study 11** ([html](dissipation-theory--Study-11.html)).  Calculate dissipation versus height over a sample with properties similar to Rachael's PM6:Y6 and compare to Marohn's analytical expression derived in the thick-sample limit.

- **Study 12** ([html](dissipation-theory--Study-12.html)).  Calculate dissipation versus charge density for a representive perovskite sample.

- **Study 13** ([html](dissipation-theory--Study-13.html)).  Plot $a_{\mathrm{max}}$ contours in the $(\epsilon^{\prime}_{\mathrm{s}}, \epsilon^{\prime\prime}_{\mathrm{s}})$ plane, keeping in mind that $\epsilon^{\prime\prime}_{\mathrm{s}}$ is negative.

- **Study 14** ([html](dissipation-theory--Study-14.html)).  Calculate dissipation $\gamma_{\perp}$ versus charge density $\rho$ for a representive perovskite sample. Compare the exact result to the low-density exapansion and an analytical expression for $\gamma_{\perp}^{\mathrm{max}}$. Both these approximations are only valid in the infinite-sample limit, so use Model 2 with the dielectric overlayer thickness set to zero. Compare the infinite-sample Model 2 result to a finite-sample Model 1 result, to check the validity of the infinite-sample approximation used to obtain an analytical result for the height dependence of the $\gamma_{\perp}$.

- **Study 15** ([html](dissipation-theory--Study-15.html)).  Calculate dissipation versus height over a sample with properties similar to Rachael's PM6:Y6 and compare to Marohn's analytical expression derived in the thick-sample limit. This notebook recalculates the successful fit in Study 11 ([html](dissipation-theory--Study-11.html)) and further explores the result.

- **Study 16** ([html](dissipation-theory--Study-16.html)). Update the fits in Study 15 ([html](dissipation-theory--Study-15.html)) using a slightly different consensus sample mobility.

- **Study 17** ([html](dissipation-theory--Study-17.html)).  Test drive the new BLDS code in `dissipationtheory.dissipation`.

- **Study 18** ([html](dissipation-theory--Study-18.html)).  Test drive the new LDS code in `dissipationtheory.dissipation`.

- **Study 19** ([html](dissipation-theory--Study-19.html)).  Test drive the new `BLDSData` object in `dissipationtheory.data`.

- **Study 20** ([html](dissipation-theory--Study-20.html)).  Explore how the BLDS signal depends on mobility and charge density.  Plot the $B^{(2)}(\omega_{\mathrm{m}}=0)$ integral versus charge density $\rho$, for selected dielectric constants.  Generate a range of conductivities $\sigma_0$ and compute the associated roll-off frequency $\omega_0 = \sigma_0/\epsilon_0$.  Plot the BLDS spectrum for various values of the charge density $\rho$, with the mobility $\mu$ fixed. Plot the low-frequency limit of the BLDS frequency shift versus the charge density, with the mobility fixed.

- **Study 21** ([html](dissipation-theory--Study-21.html)).  I have created a new module, `dissipation2.py`, in which the semiconductor properties are input in terms of conductivity and charge density instead of mobility and charge density. Explore the new module.

- **Study 22** ([html](dissipation-theory--Study-22.html)).  I have created a new data-analysis module, `data2.py`, in which the BLDS spectrum is fit to extact charge conductivity and charge density. Use the module to analyze representative BLDS spectra.  Fit representative PM6:Y6 BLDS spectra.

- **Study 23** ([html](dissipation-theory--Study-23.html)).  Plot cantilever friction and BLDS signal versus conductivity and charge density.

- **Study 24** ([html](dissipation-theory--Study-24.html)).  Plot cantilever friction versus conductivity, similar to Lekkala 203 Figures 7(b) and 9(b), but for (1) perpendicular friction and (2) plotted versus conductivity and not charge density.

- **Study 25** ([html](dissipation-theory--Study-25.html)).  For a chosen set of cantilever and sample parameters, plot versus charge density $\rho$ the

  - low-frequency BLDS frequency shift $|\Delta f_{\mathrm{BLDS}}(0)|$ and
  - cantilever friction $\gamma_{\mathrm{\perp}}$.

  Plot these quantities versus, respectively, the unitless parameters
  
  - $(h/\lambda_{\mathrm{D}})^2$, with $h$ the tip-sample separation and $\lambda_{\mathrm{D}}$ the Debye length, and
  - $\omega_0/(\epsilon_{\mathrm{s}}^{\prime} \omega_{\mathrm{c}})$, 
  
  with $\omega_0 = \sigma/\epsilon_0$, $\sigma$ the conductivity, $\epsilon_{\mathrm{s}}^{\prime}$ the real part of the dielectric constant, and $\omega_{\mathrm{c}}$ the cantilever resonance frequency.
Compare Marohn's numerical calcualtions to Loring's low-density and high-density approximations for $|\Delta f_{\mathrm{BLDS}}(0)|$.

- **Study 26** ([html](dissipation-theory--Study-26.html)).  Loring's clear, revised equations are writtien in terms of a new unitless integral $K$, not a correlation function $C$ (Leakkala) or a response function $R$ (Marohn). The code in `dissipation.py` and `dissipation2.py` writes the friction and BLDS frequency shift in terms of a correlation function $C$ introduced in Leakkala's 2013 JCP paper. In `dissipation3.py` I rewrite the `dissipation.py` code in terms of Loring's unitless $K$ integral, elimating extranneous factors of $k_{\mathrm{b}} T$. In `dissipation3.py` I follow the convention of `dissipation2.py`, where the sample's dependent variables are conductivity $\sigma$ and charge denstiy $\rho$, not the convention in `dissipation.py`, where the sample's dependent variable are conductivity $\sigma$ and mobility $\mu$.

- **Study 27** ([html](dissipation-theory--Study-27.html)). The pure-Python objects `CantileverModel`, `SampleModel1`, and `SampleModel2` offer a better way to input simulation parameters, because you can input parameters with units, but the pure-Python computations are painfully show. Work out how to pass parameters from `CantileverModel` to `CantileverModelJit`, from `SampleModel1` to `SampleModel1Jit`, and from `SampleModel2` to `SampleModel2Jit`. We can now enter parameters using the pure-Python objects, then transfer the parameters to the `numba/jit` objects for fast computations.

- **Study 28** ([html](dissipation-theory--Study-28.html)).  Redo Study 26 ([html](dissipation-theory--Study-26.html)) using `numba/jit`-accelerated functions coded in `dissipation3.py`. The `numba/jit` functions are 100 to 200 times faster than their pure-Python counterparts run in Study 26 ([html](dissipation-theory--Study-26.html)), enabling us to plot here a more detailed BLDS spectrum and explore friction and the zero-frequency limit of the BLDS spectrum as a function of many more conductivity points.

- **Study 29** ([html](dissipation-theory--Study-29.html)).  I have rewritten the code in `dissipation4.py` to require the user to explicitly input the tip charge’s $z$ location. In this notebook I test drive the new code. Check that, for an “infinitely thick” sample, the BLDS frequency shift at $\omega_{\text{m}} = 0$ agrees with Loring’s $\rho \rightarrow 0$ and $\rho \rightarrow \infty$ limiting expressions.  The numerical calculation of the low-frequency limit of the BLDS spectrum agrees with the Loring's expansions at both low denstity and high density.  To reach agreement, it is important that the sample be very thick --- 100 times the tip-sample separation.

- **Study 30** ([html](dissipation-theory--Study-30.html)).  Compute the capacitance of a sphere over a metal plane numerically using the method outlined by Xu and co-workers. See Xu, J.; Li, J.; Li, W. Calculating Electrostatic Interactions in Atomic Force Microscopy with Semiconductor Samples. AIP Advances (2019) 9(10): 105308,  [doi:10.1063/1.5110482](https://doi.org/10.1063/1.5110482).

- **Study 31** ([html](dissipation-theory--Study-31.html)).  Try to compute the capacitance of a cone over a metal numerically, using the method outlined by Xu and co-workers, cited above. Clean up the code in Study 30. To get a non-diverging charge distribution for the code, I had to employ a large filtering factor. The voltage errors are significant, on the order of five percent or more. The total charge on the cone is not a sensitive function of the number of image-charge grid points.

- **Study 32** ([html](dissipation-theory--Study-32.html)).  Compute the capacitance of a sphere using the boundary point method, with 3200 and 12800 voltage-test points, and compare the calculated capacitance to the expected result.  The calculated capacitance gets larger, not smaller, when the number voltage-test points is increased.  I hypothesize that this divergence is caused by using standard sphere parametrization, where the area goes to zero at the poles. Using randomly-located charge points, however, does not significantly improve the capacitance error; in this case the error is not strongly correlated with the matrix condition number or the relative narrowness of distribution governing nearest-neighbor distances.  I conclude that getting a capacitance error below 1% using the boundary element method probably requires 10,000’s of voltage-test points and 10's of minutes of computation time.

- **Study 33** ([html](dissipation-theory--Study-33.html)).  Numerically compute the capacitance of a sphere-tipped cone over a metal using *exactly* the method of Xu and co-workers.  See Xu, J.; Li, J.; Li, W. Calculating Electrostatic Interactions in Atomic Force Microscopy with Semiconductor Samples. AIP Advances (2019) 9(10): 105308,  [doi:10.1063/1.5110482](https://doi.org/10.1063/1.5110482).  Benchmark the method by computing the capacitance, and capacitance derivatives, of a sphere over a ground plane.  This study includes a lengthy introduction, with references, and a methods section, with typeset equations.  I reproduce Xu’s Fig. 3 plot of force versus tip-sample separation for a sphere-cone over a metal and, for comparison, plot the force predicted by my numerical model. To compare their calculated force to mine, I digitized Xu's Fig. 3 data using  WebPlotDigitizer. Plotting Xu’s normalized force and my calculated normalized force versus $h/r$, I find that the two calculations agree to within 0.25 percent, a reasonable number given the finite resolution of the WebPlotDigitizer program.

- **Study 34** ([html](dissipation-theory--Study-34.html)).  Numerically compute BLDS spectra and friction for a cantilever oscillating in the perpendicular geometry. Plot the (1) BLDS spectrum versus charge density and scaled charge density; (2) zero-frequency BLDS point versus charge density and scaled charge density; (3) BLDS roll-off frequency versus conductivity and dielectric constant; (4) friction versus charge density and scaled frequency for (a) various dielectric constant imaginary parts and (b) various mobilities.

- **Study 35** ([html](dissipation-theory--Study-35.html)).  Numerically compute Lekkala and Loring’s reaction-field Green’s functions $K_0$, $K_1$, and  $K_2$ and plot them versus charge location $z_\mathrm{c}$, for (1) a metal and (2) a semiconductor. Show that the metal’s Green’s functions are just the image-charge potential and are therefore real. Show that the semiconductor’s Green’s functions differs from the metal’s, and have imaginary components.

- **Study 36** ([html](dissipation-theory--Study-36.html)).  Loring has proposed an energy function for test charges interaction with a semiconductor sample. The (negative) derivative of this energy function is a force. Compare Loring’s expression for the force to Xu’s published results, our calculation of Xu’s results, and the standard Kelvin probe formula.

- **Study 37** ([html](dissipation-theory--Study-37.html)).  Compare 
$f_2 \: [\mathrm{Hz}/\mathrm{V}^2]$ versus $h \: [\mathrm{nm}]$ data measured over gold to calculations employing the following tip models: (a) Two approximations describing a spherical tip (Loring); (b) Hoepker’s analytical sphere-plus-cone model; and (c) Marohn’s numerical sphere-plus-cone model. Perform the fit using Marohn’s numerical sphere-plus-cone model with the tip radius and cone angle as best-fit parameters.  Conclude that a cone-plus-sphere tip model is required to fit $f_2$ versus $h$ data over a metal.  Being able to fit $f_2$ versus $h$ data to Marohn’s numerical model of a sphere-plus-cone tip over a metal sample is a significant finding, because this model can be extended to a semiconductor sample.

- **Study 38** ([html](dissipation-theory--Study-38.html)).  The code in `dissipation5.py` now implements Roger Loring’s revised theory for the non-contact friction and broadband local dielectric spectroscopy frequency shift experienced by a charged cantilever, idealized as a point probe, over a semiconductor. Check that, for an "infinitely thick" sample, the BLDS frequency shift at $\omega_{\mathrm{m}} = 0$ has the expected dependence on charge density and, at $\rho \rightarrow 0$ and $\rho \rightarrow \infty$, agrees with Loring's analytical limiting-case formulas. Find that the BLDS frequency shift does not show the expected trend with scaled charge density.  

- **Study 39** ([html](dissipation-theory--Study-39.html)). Repeat the Study 34 analysis using `dissipation5.py` code.

- **Study 40** ([html](dissipation-theory--Study-40.html)).  Examine closely the dependence of the $K_2(\omega_{\mathrm{m}})$ integral on charge density and dielectric constant.  Define a new unitless charge density $\rho_3$ such that the $K_2$ integral reaches its half point at $\rho_3 = 1$.

- **Study 41** ([html](dissipation-theory--Study-41.html)).  Repeat Study 34 employing a perovskite-like sample and the `dissipation5.py` code, which uses the new Loring formulas for BLDS frequency shift and non-contact friction.  In this study I realize a nice, compact way to loop over material parameters and generate a composite figure with a legend; the method does not require much new code.

- **Study 42** ([html](dissipation-theory--Study-42.html)). Repeat the Study 39 analysis using Loring’s new 2025-04-17 formulas implemented in the `dissipation6.py` code. Find that the BLDS frequency diverges at high modulation frequency.

- **Study 43** ([html](dissipation-theory--Study-43.html)). Representative BLDS spectra and perpendicular friction plotted versus unitless parameters. Repeat the Study 39 analysis using Loring's new 2025-05-14 formulas implemented in the `dissipation7.py` code.  The new formula correctly predicts a dc cantilever frequency shift that increases with increasing charge density (light intensity).

- **Study 44** ([html](dissipation-theory--Study-44.html)). Testing new functions for calculating $\theta_{I}$, $\theta_{II}$, and $K_{\ell}$. Test code for calculating the functions $\theta_{I}$, $\theta_{II}$, and $K_{\ell}$.  This notebook tests functions imported from `dissipationtheory8a.py` (pure Python) and `dissipationtheory8b.py` (numba/jit).  These functions are tested against functions imported from `dissipationtheory7.py` (pure Python and numba/jit).  In contrast with the functions in `dissipationtheory7.py`, the functions in `dissipationtheory8a.py` and `dissipationtheory8a.py` are well-behaved in the $\omega \rightarrow 0$ limit. The function $K_2$ is computed at a selected position for representative Type I and Type II samples.  We show that $K_0$ computed over a "metallic" Type I and Type II sample gives the expected unitless image-charge potential.

- **Study 45** ([html](dissipation-theory--Study-45.html)). Test code for computing friction, $\gamma$, and frequency shift, $\Delta f_{\mathrm{stat}}$ and $\Delta f_{\mathrm{dyn}}$, for a cantilever oscillating in the perpendicular geometry over a thick Type I semiconductor sample.  Import code from `dissipationtheory8a.py` and `dissipationtheory8b.py`. Develop a data class `ExptSweepConductivity` which computes and plots friction and frequency shift for varied conductivity and charge density.

- **Study 46** ([html](dissipation-theory--Study-46.html)). Develop code for a point probe of finite size. Develop code for computing friction, $\gamma$, and frequency shift, $\Delta f$, for a finite-size tip.  Resources include Loring's typeset 2025-06-09 notes; Marohn's handwritten 2025-06-10, 2025-06-11, 2025-06-12, and 2025-06-14 notes; code in `capacitancefinite.py`; and code in Study 30 ([html](dissipation-theory--Study-30.html)), Study 31 ([html](dissipation-theory--Study-31.html)), Study 33 ([html](dissipation-theory--Study-33.html)), and Study 37 ([html](dissipation-theory--Study-37.html)).  See Study 41 ([html](dissipation-theory--Study-41.html)) for a compact way to loop over material parameters and generate a composite figure with a legend.  Here I compute the capacitance (and associated derivatives) $C_0$, $C_1$, and $C_2$ of a sphere over a metal ground plane at various heights using the Xu method and the formalism developed in the above notes.  The resulting code is much more compact and readable than previously developed code in `capacitancefinite.py`.  The calculated capacitance and capacitance derivatives show excellent agreement with analytical series, except for $C_2$ at large tip-sample separation.  I suspect the problem is that the reference distance of 1 nm is too small, leading to roundoff error.  Examine this hypothesis in a subsequent notebook.

- **Study 47** ([html](dissipation-theory--Study-47.html)). Develop code for a point probe of finite size (continued). In the previous notebook I computed the capacitance (and associated derivatives) $C_0$, $C_1$, and $C_2$ of a sphere over a metal ground plane at various heights using the Xu method. The calculated capacitance and capacitance derivatives showed excellent agreement with analytical series, except for $C_2$ at large tip-sample separation. I suspected the problem was that the reference distance of 1 nm was too small, leading to roundoff error. Below I show that unless the reference height $z_{\mathrm{r}}$ is on the order of the height $h$, the integral $K_2(\omega=0, r_1 = [0, 0, h], r_2 = [0, 0, h])$ will blow up. I believe this finding explains the observed error in $C_2$ are large $h$.

- **Study 48** ([html](dissipation-theory--Study-48.html)). Develop code for a point probe of finite size (continued). Recode the functions in Study 46 ([html](dissipation-theory--Study-46.html)) to scale coordinates by the reference distance $z_{\mathrm{r}}$ stored in the sample object.  For a spherical tip with radius $r = 30$ nm represented by $N = 15$ image charges, we compute $C_0$, $C_1$, and $C_2$ for tip-sample separations spaced logarithmically between $h = r/2 = 15$ nm and $1 \mu$m.  We perform this computation for two semi-infinite samples, a "metallic" sample and a "dielectric" sample having relative dielectric constant 3.  For these two idealized samples, we compare the computed $C_{j}$'s to an analytical series solution approximated by 20 terms.  With $z_{\mathrm{r}} = 0.1$ nm, the agreement is poor.  With $z_{\mathrm{r}} \geq 10$ nm, the error is only 5 parts per million at $h = 15$ nm, decreasing to just few parts per billion at $h = 1 \mu$m.  This study demonstrates that choosing $z_{\mathrm{r}}$ appropriately can dramatically improve the accuracy of the computed capacitance derivatives, particularly the second derivative $C_2$.

- **Study 49** ([html](dissipation-theory--Study-49.html)). Develop code for a point probe of finite size (continued). I have incorporated into `dissipationtheory8c.py` the code from Study 48 ([html](dissipation-theory--Study-46.html)) determining the images charges for a spherical tip.  Below I develop code for (a) computing observables like force, friction, and frequency shift and (b) determining the image charges for a sphere-plus-cone tip.  In contrast with prior code, read the tip radius, cone angle, and cone length from the cantilever object.

- **Study 50** ([html](dissipation-theory--Study-50.html)). Run finite-tip simulations. Test drive the code in `dissipationtheory8c.py`, comparing the frequency shift measured over gold to that computed using (1) a sphere and (2) a sphere-plus-cone, both over a Type I "metallic" sample.  Both models predict the size of the frequency shift at small tip-sample separation $h$ with a reasonable tip radius and essentially no other free parameters.  Model 2 does a better job than Model 1 at predicting the frequency shift at large $h$.  These computations are painfully slow.  This is because I am modeling the gold substrate as a Type I sample, essentially a high-conductivity semiconductor, and the associated response function is very complicated and slow to integrate.  In Study 37 I implimented a sphere-plus-cone frequency shift calculation using a metal response function, which is much faster to compute.  The Study 37 calculation was fast enough to enable least-squares fitting of the data to obtain a tip radius and cone angle (this took about a minute).  Below I perform code profiling, brainstorm ways to speed up data analysis, and explore vector integration.

- **Study 51** ([html](dissipation-theory--Study-51.html)). Test and profile the code in the `dissipationtheory9a.py`.

- **Study 52** ([html](dissipation-theory--Study-52.html)). Test and profile the code in the `dissipationtheory9b.py`.

- **Study 53** ([html](dissipation-theory--Study-53.html)). Explore writing a fast `twodimCobject` object; create fast, compiled `coulombmatrix_jit` and `Kmatrix_jit` functions. In Study 50 ([html](dissipation-theory--Study-50.html)) I compared the frequency shift measured over gold at 28 tip-sample separations to the frequency shift computed, using `twodimCobject` from `dissipationtheory8c.py`, for two tip models, (1) a sphere and (2) a sphere-plus-cone, both over a Type I “metallic” sample.  These computations were painfully slow.  For a $15 \times 30 = 450$ element array, the `twodimCobject.solve` function took 4.3 seconds to execute. It consequently took *two minutes* to calculate frequency versus tip-sample separation data, too slow for least-squares fitting of data to obtain the tip radius and cone angle.  The limiting step in the computation is setting up the Coulomb matrix and the $K_n$ matrices.  Below I develop fast, compiled functions for setting up these matrices and I benchmark their execution time for a $15 \times 20 = 300$ element array.  These functions are `coulombmatrix_jit` (0.2 ms) and `Kmatrix_jit` (0.3 ms for metal, 3 ms for Type III sample). Creating a compiled function to set up the $K_n$ matrices for a Type III sample required (1) using a newly written `integrand3jit` function with simple inputs; (2) replacing `scipy.integrate.quad_vec` with a 30-point Newton-Cotes integration; and (3) writing the function `Kmatrix_jit` *very* carefully so that `jit` can compile it.  Further work is required to benchmark the Newton-Cotes integration againt `scipy.integrate.quad_vec` for a range of sample parameters. Nevertheless, the new compiled functions suggest that it should be possible to calculate a frequency shift to experimental accuracy for a numerically modeled tip in under 1 ms for a metal and in under 20 ms for a Type I, II, or III semiconductor sample.

- **Study 54** ([html](dissipation-theory--Study-54.html)). Write and test a fast `twodimCobject` built around `KmatrixIII_jit` and `KmatrixIV_jit`.  I find that `KmatrixIV_jit` performs well and yields the expected sphere capacitance derivatives.  I find that `KmatrixIII_jit` performs poorly but can be fixed by using a different scaling parameter for each matrix element's integral.  This leads to a breakdown of my paper-and-pencil linear algebra.  So while I can write code to quickly and accurately compute the $K_n$'s, I now have to deal with an explosion of scaling parameters, which my paper-and-pencil solutions do not presently account for.  I need to go back to my paper-and-pencil linear algebra and work out a fix. (This notebook is a bit of a mess, with different sections written *not* in chronological order.)

- **Study 55** ([html](dissipation-theory--Study-55.html)). Optimize Newton-Cotes integration of the integral ${\cal I}_{2}(x)$ for $0 \leq x \leq 2$. The reaction field matrices $K_{\ell}$ can be written in terms of a unitless integral ${\cal I}_{\ell}(x)$ given below. The $x$ variable will likely be limited to the range $0 \leq x \leq 2$.  Over this range, optimize the computation of the integral using the Newton-Cotes method.  We find an optimum order $N \sim 30$ and optimum upper integration bound of $y_{\mathrm{max}} \sim 15$.

- **Study 56** ([html](dissipation-theory--Study-56.html)). Explore a Fourier-transform based approach to integrating ${\cal I}_{2}(x)$. The Newton-Cotes integrator explored previously performs very poorly at $x \geq 2$, limiting our calcultions of frequency shift and friction to tip-sample separation $h \geq R/4$, with $R$ the tip radius.  If we had an integrator working to $x \sim 5$ then we could perform calculations down to $h \leq R/10$, which would be desirable.  Here we explore a Fourier-transform based approach to integrating ${\cal I}_{2}(x)$.  In contrast with the Newton-Cotes integrator, the FT integrator maintains excellent accuracy for ${\cal I}_{2}(x)$ at large $x$, although at the cost of a 7-fold increase in execution time (from 3 to 21 microseconds per integration).  The FT integrator has horrendous errors for ${\cal I}_{0}(x)$, however, unless $N$ is very large, say $64$k.  Future effort should focus on getting the Newton-Cotes integrator to work better at large $x$, perhaps by breaking the $y$ axis into subregions informed by our knowledge of the Bessel-function zeros.

- **Study 57** ([html](dissipation-theory--Study-57.html)). An improved Newton-Cotes integrator for ${\cal I}_{\ell}(x)$ valid at large $x$. Here we develop a Newton-Cotes integrator to calculate ${\cal I}_{\ell}(x)$ accurately at large $x$.  We achieve this goal by breaking the integration axis into subregions, informed by our knowledge of the Bessel-function zeros.  The resulting integrator achieves a fractional error below 20 parts per million for $0 \leq x \leq 10$, corresponding to a tip-sample separation of $R/20 \leq h < \infty$.  The execution time is reasonably good.

- **Study 58** ([html](dissipation-theory--Study-58.html)). Write a fast `twodimCobject` object (revisited). Now that I have an accurate and reasonably fast integrator in place ([Study 57](dissipation-theory--Study-57.html)), let me revisit writing a fast `twodimCobject` object for simulating the capacitance, dissipation, and frequency shift of a finite tip ([Study 53](dissipation-theory--Study-53.html)).  Below I develop code for calculating cantilever observables over a sample consisting of a semi-infinite metal (Type IV sample) and semi-infinite semiconductor (Type III sample).  The code is a combination of compiled functions and uncompiled Python.  The execution time is reasonably good --- 10 ms for a metallic / Type IV sample and 50 ms for semiconductor / Type III sample. Accuracy of the code was demonstrated by computing capacitance and capacitance derivatives versus height, which can be compared to series solutions for the case of a sphere over a (1) semi-infinite metal sample and (2) semi-infinite dielectric sample.  The relative accuracy was highly dependent on tip-sample separation and was in the 10's of part per million range at experimentally relevant tip-sample separations.

- **Study 59** ([html](dissipation-theory--Study-59.html)). Test drive the new `twodimCobject` object. I have moved the code developed in [Study 58](dissipation-theory--Study-58.html) into `dissipation9e.py`.  Take the new code for a test drive.

- **Study 60** ([html](dissipation-theory--Study-60.html)). Understand and improve the sphere-plus-cone model in the `twodimCobject` object. In `2025-07-10--jam99--20240222-rerun-ringdown-NiOx-U551--Study-1.ipynb` ([html](file:///Users/jam99/Dropbox/_JAM_MS__Cohn202407__BLDS/notes-and-scripts/2025-07-10--jam99--20240222-rerun-ringdown-NiOx-U551--Study-1.html)), I fit frequency and dissipation data collected versus voltage and tip-sample separation using a sphere-plus-cone tip model.  I found that the calculated frequency diverged at *large* tip-sample separation $h$.  Looking at the image charges, I observed the two leading tip charges became large and of oppositite sign at large $h$.  Here I show that the divergence of the image charges, and the calculated frequency, can be eliminated by adding a small filtering parameter $\alpha = 1 \times 10^{-6}$ without affecting the calculated cantilever frequency significantly.

- **Study 61** ([html](dissipation-theory--Study-61.html)). Test drive the new `twodimCobject` object in`dissipation10e.py`. Augment `dissipation9e.py` to compute the BLDS spectrum using Loring's 07/23/25 pdf report and Marohn's 08/01/25 handwritten notes.  Create a new  `twodimCobject` object in`dissipation10e.py` that computes the cantilever frequency shift with (1) an AC voltage and (2) an AM-modulated AC voltage applied to the cantilever tip.

- **Study 62** ([html](dissipation-theory--Study-62.html)). Unit testing the Type III sample computations. In anticipation of adding code to calculate the frequency shift and dissipation of Type I and Type II samples, develop unit tests for Type III and Type IV samples. In these tests we compare the real and imaginary parts of the $K_n$ integrals ($n = 0, 1, 2$) computed using `K_jit` in `dissipation9b.py` to those computed using `KmatrixIII_jit` and `KmatrixIV_jit` in `dissipation10e.py`. These unit tests reveal that the integration scheme in `KmatrixIII_jit` in `dissipation10e.py` has relatively poor accuracy and needs improvement. Below we develop an improved integration scheme, `KmatrixIII_jit` in `dissipation11e.py`.  

- **Study 63** ([html](dissipation-theory--Study-63.html)). A new integration algorithm and more unit testing of Type III sample computations. Unit testing of the $K_n$ functions `dissipation11e.py` revealed that the agreement between the (fast) new integration scheme in `dissipation11e.py` and the (slow) integration scheme in `scipy.integrate` was unacceptably poor at low frequency, especially for the imaginary part of the integral.  Here we examine the integrand and devise an improved fast integration scheme based on a logarithmic change of variables.  This new integration algorithm is coded in `dissipation12e.py`, with some preliminary unit tests coded in `test_dissipation12e.py`.  Below we carry out comprehenvive unit testing of the $K_n$ functions by looping over 36288 combinations of the variables $\boldsymbol{s}_j$, $\boldsymbol{r}_k$, $\omega$, $\epsilon_{\mathrm{s}}$, $\rho$, and $\sigma$.  Breaking the integrand into 10 sub-intervals, we achieve an rms error in the six (real and imaginary) $K_1$, $K_2$, and $K_3$ values of $\epsilon \leq 0.036$%.  Each integration takes less than 8 ms.

- **Study 64** ([html](dissipation-theory--Study-64.html)). Code up and unit-test the computation of the $K_n$ integrals for Type I and Type II samples. Here we test four new functions in `dissipation13e.py` -- `rpI_jit`, `KmatrixI_jit`, `rpII_jit`, and `KmatrixII_jit`.  We run unit tests over 34k sample parameters, as in Study 63, comparing $K_n$ integrals computed using the (slow) `scipy.integrate` function in `dissipation9b.py` to those computed using the (fast) bespoke integration algorithm in `dissipation13e.py`.  Using 10 breakpoints in the computation of the integrals, the root-mean-square error in the $K_n$ integrals is worse for Type I and Type II sample than for Type III samples, but is nevertheless below 0.5%.  The run time for Type I and II samples is a factor of two longer than for Type III samples. We conclude that the accuracy and run time of the Type I and Type II sample $K_n$ calculations are sufficiently good to warrant analyzing data.

- **Study 65** ([html](dissipation-theory--Study-65.html)). We have added Type I and Type II support to the `twodimCobject` object in `dissipation13e.py`. We demonstrate this functionality by calculating, for a finite tip, the dc frequency shift and dissipation versus tip-sample separation and the BLDS spectrum for Type I, II, and III samples. For 25 height points, the frequency and friction calculation took (user CPU time) 4.1s, 2.5s, 1.7s, and 4.1s for Type I, II, and III samples, respectively. Sample I was 15 nm thick and exhibited a small negative friction, which is unphysical.  This error remained when the number of breakpoints was increased from 15 to 45, and so is likely not caused by imperfect integration. The error changed with the $\alpha$ parameter, but using a larger alpha did not eliminate the negative-friction error. For 40 frequency points, the BLDS spectrum calculation took (user CPU time) 39s, 8.5s, and 7.3s for Type I, II, and III samples, respectively.  The BLDS spectrum for the Type II and Type III sample showed the expected roll off.  The BLDS spectrum from Sample I was negligibly small, but exhibited two distinct roll-offs.

- **Study 66** ([html](dissipation-theory--Study-66.html)). Demonstrate fast matrix multiplication using `pytorch` and the GPU. For large arrays, show that GPU multiplication using `pytorch` is faster than CPU multiplication using `numpy`.  Frustratingly, the Apple Silicon GPU is limited to single precision.  See also the following stand-alone python programs I have written to speed-test computations on the GPU using torch, on the GPU using jax, and on the CPU with parallel processing via `concurrent.futures`: `gpu1.py`, `jax1.py`, `multi1.py`, and `multi2.py`.

- **Study 67** ([html](dissipation-theory--Study-67.html)). The goal of this study is to translate representative numba-compiled python functions, running on the CPU, to torch code, running on the GPU. I develop such code for computing (1) the Coulomb matrix and (2) the $K_n$ matrices for a Type III sample (a semi-infinite semiconductor). I begin by reproducing code for the integrand `rpIII_jit` from `dissipation13e.py`. I develop and time torch implementations of the Coulomb matrix calculation. The first implementation, suggested by GitHub Copilot running in Visual Studio Code, uses loops and is slow (48 ms for $21 \times 21$ computations). The second implementation, writting using the `vmap` function, is fast (64 $\mu$s for $21 \times 21$ computations). I next created a torch function for computing the reflection coefficient $r_p$ and the $K_n$ integrals for a Type III sample. The torch `vmap` function was used to thread the $K_n$ integral function over the $r_k$ and $s_j$ matrices to create three matrices $K_0$, $K_1$, and $K_2$. The resulting function `KmatrixIII_torch`, threaded over $21 \times 21$ values of ($r_k, s_j$), took 5.5 ms to run on the GPU. This compares favorably to the 7.4 ms run time of the function `KmatrixIII_jit` running on the CPU.

- **Study 68** ([html](dissipation-theory--Study-68.html)). Having sped up the calculation of the $K_n$ matrices slighly by replacing compiled numpy operations on the CPU with torch computations on the GPU, here I try to obtain a further speedup using parallel processing.  I explore parallel processing using the `concurrent`, `multiprocessing`, and `multiprocess` packages.  All these packages employ pickling.  The `multiprocess` package (using `dill` under the hood) can pickle complicated objects like `twodimCobject`.  Even so, to use `multiprocess` I had to rewrite `twodimCobject` to use `SampleModel3` instead of `SampleModel3Jit` (which was unpickleable). The new `twodimCobject` can be found in `dissipation14e.py` along with `twodimCobjectExperimental` which has mockup code looping over the `.solve()` function using (Method 1) `concurrent.futures.ThreadPoolExecutor`, (Method 2) `multiprocess.Process`, and (Method 3) `concurrent.futures.ProcessPoolExecutor`.  Method 1 took milliseconds, but was no faster than looping; Methods 2 and 3 took seconds. In summary, I have been unable to achieve a further speedup using parallel processing, at least running in a Jupyter notebook.  Future work should focus in implementing parallel computations on the GPU instead.

- **Study 69** ([html](dissipation-theory--Study-69.html)). I used `vmap` to compute the $C$ and $K_n$ matrices at many positions *and* frequencies together on the GPU.  This innovation enabled the calculation of the AC frequency shift 64 times faster than the previous CPU-based calculation. An additional factor of three speed-up was realized by approximating the AM frequency shift as a scaled version of the AC frequency shift. I then demonstrated that the new GPU-based code can compute a BLDS frequency shift fast enough to enable least-squares fitting of data.  To do this, I used the existing CPU-based code to compute the frequency shift in an AM modulation experiment; this frequency shift was treated as an articifial signal. I fit this artificial signal to a scaled AC frequency shift, computed using the new GPU code. This fit recovered the expected dielectric constant, conductivity, and charge density in under 10 seconds.  Next, extend this approach to a Type I sample and then try to fit experimental data.

- **Study 70** ([html](dissipation-theory--Study-70.html)). We want to fit BLDS spectra collected at multiple heights to a set of common fit parameters.  Before extending the Study 69 GPU computations to Type I and Type II samples, extend the Type III sample calculation to include an array of heights as well as an array of frequencies.  Do this by rewriting the `rp_III_integrator` function to accept a new input, a vertical displacement.  Use `torch.vmap` to create a mapping of the new `rp_III_integrator` function onto arrays of height changes $\Delta h$ was well as frequencyes $\omega$ and the vectors $s_j$ and $r_k$.  The height mapping, surprisingly, is no faster than looping.  Employing the mapping does, however, simplify the code considerably.  Write GPU code to compute both and $\Delta f_{\mathrm{ac}}$ and $\Delta f_{\mathrm{am}}$.  Test the new GPU code against CPU code and observe agreement at the few part-per-thousand level. Use the CPU code to generate "data" consisting of BLDS spectra at six heights.  Use the new GPU function to simultaneously fit these six BLDS spectra to obtain best-fit values for dielectric constant, conductivity, and charge density. The fit takes about two minutes and recovers the expected sample parameters.

- **Study 71** ([html](dissipation-theory--Study-71.html)).  Develop code for computing the AC and AM frequency shift for a Type I sample.  Compare the real and imaginary parts of the $K_n$ integrals computed using CPU and GPU code over a wide range of sample parameters. The $r_p$ function is discontinuous when computed on the GPU. This pathology suggests that the error in $\mathrm{Im}[K_2]$ at high $\sigma$ and small $\rho$ is a problem with $r_p$ and not with the integration procedure.   There are a couple of possible sources of the faulty $r_p$, keeping in mind that `torch` code on the GPU is running in single precision and $\theta_1$ and $k / \eta$ are complex numbers.  We could have errors in the (1) the square root of a complex number in $\theta_1$, (2) the square root of a complex number in $k / \eta$, or (3) evaluating `sinh`, `cosh`, or `tanh` with complex argument $\theta_1$.

- **Study 72** ([html](dissipation-theory--Study-72.html)).   Develop code for computing dissipation and frequency shift for a point probe over a Type I, Type II, and Type III sample, encoding formulas provided by Roger Loring on 2026-12-05.  The code developed here is built on the `numba` code in `dissipation13e.py` and the example computations in `dissipation-theory--Study-65.ipynb`; computations are thus performed using compiled code on the CPU, not the GPU.  Perform a test calculation for a Type I sample.  In this test, compare point-probe results to the results of finite-tip/sphere calculation computed using `twodimCobject` in `dissipation13e.py` at large tip-sample separation where Loring's point-probe approximation is valid.